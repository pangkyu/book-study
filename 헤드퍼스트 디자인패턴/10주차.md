## 복합패턴

- 여러 디자인 패턴을 조합하여 일반적이고 반복되는 문제를 해결하는 패턴
- 단일 패턴으로는 해결하기 어려운 복잡한 문제를 여러 패턴의 장점을 결합해서 해결합니다.

=> 실무에서는 하나의 패턴으로 해결되는 경우보다 여러 패턴을 조합해서 문제를 풀어야하는 경우가 많습니다!

단, 복합 객체를 만들 때도 상황에 따라 필요한 패턴만 선택적으로 조합하는 것이 중요합니다.

### MVC (Model - View - Controller)

- Observer 패턴 : 모델이 변경되면 뷰에게 알림
- Strategy 패턴 : 컨트롤러가 뷰의 동작 전략을 결정
- Composite 패턴 : 뷰는 계층적 구조로 구성

데이터(모델)부분과 뷰 부분, 그리고 두 가지를 컨트롤하는 3가지로 나누는 패턴입니다.

```js
// Model (Observer 패턴의 Subject)
class CameraModel {
  private cameras: Camera[] = [];
  private observers: Observer[] = [];

  // Observer 등록
  attach(observer: Observer): void {
    this.observers.push(observer);
  }

  detach(observer: Observer): void {
    const index = this.observers.indexOf(observer);
    if (index > -1) {
      this.observers.splice(index, 1);
    }
  }

  // 변경 알림
  notify(): void {
    this.observers.forEach(observer => observer.update(this));
  }

  // 데이터 변경 메서드
  addCamera(camera: Camera): void {
    this.cameras.push(camera);
    this.notify(); // 자동으로 View 업데이트
  }

  removeCamera(id: string): void {
    this.cameras = this.cameras.filter(c => c.id !== id);
    this.notify();
  }

  getCameras(): Camera[] {
    return [...this.cameras];
  }
}

// View (Observer 패턴의 Observer, Composite 패턴)
interface Observer {
  update(model: CameraModel): void;
}

class CameraListView implements Observer {
  private element: HTMLElement;
  private controller: CameraController;

  constructor(element: HTMLElement, controller: CameraController) {
    this.element = element;
    this.controller = controller;
  }

  // Model 변경 시 호출됨
  update(model: CameraModel): void {
    this.render(model.getCameras());
  }

  private render(cameras: Camera[]): void {
    this.element.innerHTML = '';
    cameras.forEach(camera => {
      const cameraElement = document.createElement('div');
      cameraElement.innerHTML = `
        <span>${camera.name}</span>
        <button data-id="${camera.id}">삭제</button>
      `;

      // 사용자 이벤트를 Controller에 위임
      cameraElement.querySelector('button')?.addEventListener('click', (e) => {
        const id = (e.target as HTMLElement).dataset.id!;
        this.controller.handleDelete(id);
      });

      this.element.appendChild(cameraElement);
    });
  }
}

// Controller (Strategy 패턴)
class CameraController {
  private model: CameraModel;
  private view: CameraListView;

  constructor(model: CameraModel, view: CameraListView) {
    this.model = model;
    this.view = view;

    // Model과 View 연결
    this.model.attach(this.view);
  }

  // 사용자 액션 처리
  handleAdd(camera: Camera): void {
    this.model.addCamera(camera);
  }

  handleDelete(id: string): void {
    this.model.removeCamera(id);
  }
}

// 사용 예시
const model = new CameraModel();
const element = document.getElementById('camera-list')!;
const controller = new CameraController(model, new CameraListView(element, controller));

// Controller를 통해 조작
controller.handleAdd({ id: '1', name: 'Camera 1' });
controller.handleAdd({ id: '2', name: 'Camera 2' });
// View가 자동으로 업데이트됨!
```

### 장단점

**장점**

- 단일 객체와 복합 객체를 동일하게 여기기 때문에 묶어서 연산하거나 관리할 때 편합니다.
- 객체에 따라 다르게 처리하지 않고 동일 취급해야 할 때 사용합니다.
- 투명성을 이용하여 클라이언트 사용을 단순화할 수 있습니다.

**단점**

- 재귀 호출 특징 상 트리 뎁스가 길어질수록 라인 단위의 디버깅에 어려움이 생깁니다.
- 복합체 패턴은 수평적, 수직적 모두 객체를 확장할 수 있으나 수평적 방향으로만 확장하도록 리프를 제한한 컴포지트를 만들기는 어렵다
