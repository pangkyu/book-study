## 2. 옵저버 패턴

한 객체의 상태가 변경되면 그 객체에 의존하는 다른 객체에게 자동으로 알림을 보내고 업데이트하는 디자인 패턴

1-N 관계에서 사용되며, 발행-구독 패턴으로 사용합니다

**핵심 개념**
Subject(주체) : 상태를 갖고 있으며 상태 변경 시 옵저버들에게 알립니다.
Observer(관찰자) : Subject를 구독하고 알림을 받아 업데이트를 수행합니다.
구독/해지 : 옵저버는 언제든지 구독/해지가 가능합니다.

**작동 원리**
등록 요청 > 등록 > 주체 값 변경 시 구독 > 해제 요청 > 해제(주체 값 변경에도 값 알 수 없음 )

리액트에서는 옵저버 패턴을 state와 props로 자연스럽게 대체할 수 있습니다.
-> 상태가 변경되면 그 상태를 참조하는 모든 컴포넌트가 리렌더링

```ts
class WeatherData {
  constructor() {
    this.currentConditionsDisplay = null;
    this.statisticsDisplay = null;
    this.forecastDisplay = null;

    this.temperature = 0;
    this.humidity = 0;
    this.pressure = 0;
  }

  getTemperature() {
    return this.temperature;
  }

  getHumidity() {
    return this.humidity;
  }

  getPressure() {
    return this.pressure;
  }

  measurementsChanged() {
    const temp = this.getTemperature();
    const humidity = this.getHumidity();
    const pressure = this.getPressure();

    this.currentConditionsDisplay.update(temp, humidity, pressure);
    this.statisticsDisplay.update(temp, humidity, pressure);
    this.forecastDisplay.update(temp, humidity, pressure);
  }

  setMeasurements(temp, humidity, pressure) {
    this.temperature = temp;
    this.humidity = humidity;
    this.pressure = pressure;

    this.measurementsChanged();
  }
}
```

```js
class CurrentConditionsDisplay {
  update(temp, humidity, pressure) {
    console.log("현재 상태:", temp, humidity, pressure);
  }
}

class StatisticsDisplay {
  update(temp, humidity, pressure) {
    console.log("통계 갱신:", temp, humidity, pressure);
  }
}

class ForecastDisplay {
  update(temp, humidity, pressure) {
    console.log("예보 갱신:", temp, humidity, pressure);
  }
}

// WeatherData 인스턴스 생성
const weatherData = new WeatherData();

// 디스플레이 등록
weatherData.currentConditionsDisplay = new CurrentConditionsDisplay();
weatherData.statisticsDisplay = new StatisticsDisplay();
weatherData.forecastDisplay = new ForecastDisplay();

// 새로운 측정값 세팅 (자동으로 measurementsChanged 호출)
weatherData.setMeasurements(26.5, 65, 1013);
```

**부제 : 느슨한 결합**

결합 : 모듈 내부가 아닌 외부 모듈과의 연관도 또는 모듈 간 상호의존성, 소프트웨어 구조에서 결합도를 사용하여 모듈 간 관련성을 측정합니다.

느슨한 결합 -> 객체들이 상호작용할 수 있으나 서로 잘 모르는 관계
느슨한 결합을 활용하면 유연성이 아주 좋아짐 (옵저버 패턴!)

**왜 옵저버 패턴이 유연한건가요?**

1. 주체가 옵저버가 특정 인터페이스를 구현한다는 사실만 알면됩니다.
   -> 무슨 일을 하는 지 알 필요가 없음
2. 옵저버는 언제든지 새로 추가하고 제거할 수 있습니다.
   -> 주체는 옵저버 인터페이스를 구현하는 객체 목록에만 의존하므로 언제든지 새 옵저버를 추가할 수 있습니다. 또한 실행 중 다른 옵저버로 변경하거나 제거해도 문제 없습니다.
3. 주체와 옵저버는 서로 독립적으로 재사용할 수 있습니다.
   -> 서로 강결합되어 있지 않기 때문에 다른 용도로 활용할 일이 있다해도 손쉽게 재사용할 수 있습니다.
   --> 그렇다는 건 조건만 만족한다면 어떻게 변경되어도 문제가 생기지 않습니다.
