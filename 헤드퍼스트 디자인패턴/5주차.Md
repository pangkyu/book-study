## 커멘드 패턴

요청 자체를 객체로 캡슐화하는 패턴입니다.
-> 실행할 작업을 명령서처럼 포장해서 전달합니다.

일련의 행동을 특정 리시버와 연결하여 요청을 캡슐화하기 위해서는 행동과 리시버를 한 객체에 넣고 `execute()`메소드 하나만 외부에 공개하는 방법을 사용합니다.
메소드 호출에 따라 리시버가 작업을 처리하며 밖에서 볼 때는 어떤 객체가 리시버 역할을 하는지, 그 리시버가 어떤 일을 알 수 없습니다.

사용되는 예시

1. Redux

```ts
// action => command
const incrementAction = { type: "INCREMENT", payload: 1 };

// dispatch => command 실행
dispatch(incrementAction);

// redux devtool로 undo/redo 기능 사용 가능
```

2. Text Editor
   노션, 피그마 같은 서비스에서 사용자의 액션을 커멘드로 저장하여 undo/redo를 할 수 있도록 지원합니다.

```ts
const commands = [
    new InsertTextCommand('Test');
    new DeleteTextCommand(5),
    new ChangeColorCommand('#ff0000');
]
```

**장점**

1. 명령 히스토리를 저장해서 실행 취소 / 재실행같은 기능을 쉽게 구현할 수 있습니다.
2. 명령을 나중에 실행하거나 예약 실행을 할 수 있습니다.
3. 모든 작업을 기록할 수 있습니다.
4. 요청하는 객체와 실행하는 객체를 분리할 수 있습니다.

**구성 요소**

1. Command(명령) : 실행할 작업의 인터페이스 => 리시버를 참조하고 리시버의 메소드를 호출
2. ConcreteCommand(구체적 명령) : 실제 명령 구현체
3. Invoker(호출자) : 명령을 실행시키는 트리거 => 커멘드만 알고 리시버가 뭔지는 모름
4. Receive(수신자) : 실제 작업을 수행하는 객체 => 비즈니스 로직을 담당 / 커멘드 패턴 몰라도 됨

```ts
// ===== Receiver (수신자) =====
// 실제 일을 하는 객체 (TV, 에어컨 등)
class TV {
  private isOn: boolean = false;
  private volume: number = 10;

  turnOn(): void {
    this.isOn = true;
    console.log('TV가 켜졌습니다.');
  }

  turnOff(): void {
    this.isOn = false;
    console.log('TV가 꺼졌습니다.');
  }

  setVolume(level: number): void {
    this.volume = level;
    console.log(`볼륨이 ${level}로 설정되었습니다.`);
  }
}

class AirConditioner {
  private temperature: number = 24;

  setTemperature(temp: number): void {
    this.temperature = temp;
    console.log(`온도가 ${temp}도로 설정되었습니다.`);
  }
}

// ===== Command (명령 인터페이스) =====
interface Command {
  execute(): void;
  undo(): void;
}

// ===== ConcreteCommand (구체적 명령) =====
// 명령은 Receiver를 알고 있고, Receiver의 메서드를 호출함
class TVOnCommand implements Command {
  private tv: TV; // Receiver를 참조

  constructor(tv: TV) {
    this.tv = tv;
  }

  execute(): void {
    this.tv.turnOn(); // Receiver의 메서드 호출
  }

  undo(): void {
    this.tv.turnOff();
  }
}

class TVOffCommand implements Command {
  private tv: TV;

  constructor(tv: TV) {
    this.tv = tv;
  }

  execute(): void {
    this.tv.turnOff();
  }

  undo(): void {
    this.tv.turnOn();
  }
}

class VolumeUpCommand implements Command {
  private tv: TV;
  private previousVolume: number = 0;
  private amount: number;

  constructor(tv: TV, amount: number = 5) {
    this.tv = tv;
    this.amount = amount;
  }

  execute(): void {
    // 실행 전 상태 저장 (undo를 위해)
    this.previousVolume = 10; // 실제로는 TV에서 가져와야 함
    this.tv.setVolume(this.previousVolume + this.amount);
  }

  undo(): void {
    this.tv.setVolume(this.previousVolume);
  }
}

class AirConditionerCommand implements Command {
  private aircon: AirConditioner;
  private temperature: number;

  constructor(aircon: AirConditioner, temp: number) {
    this.aircon = aircon;
    this.temperature = temp;
  }

  execute(): void {
    this.aircon.setTemperature(this.temperature);
  }

  undo(): void {
    this.aircon.setTemperature(24); // 기본값으로
  }
}

// ===== Invoker (호출자) =====
// 명령을 실행시키는 리모컨
// Invoker는 Command만 알고, Receiver가 뭔지는 모름!
class RemoteControl {
  private commands: { [key: string]: Command } = {};
  private history: Command[] = [];

  // 버튼에 명령 할당
  setCommand(buttonName: string, command: Command): void {
    this.commands[buttonName] = command;
  }

  // 버튼 누르기
  pressButton(buttonName: string): void {
    const command = this.commands[buttonName];
    if (command) {
      command.execute();
      this.history.push(command);
      console.log(`[${buttonName}] 버튼이 눌렸습니다.`);
    }
  }

  // 마지막 동작 취소
  pressUndo(): void {
    const command = this.history.pop();
    if (command) {
      command.undo();
      console.log('[UNDO] 버튼이 눌렸습니다.');
    }
  }
}

// ===== 실제 사용 =====
// 1. Receiver 생성 (실제 기기들)
const livingRoomTV = new TV();
const bedroom Aircon = new AirConditioner();

// 2. ConcreteCommand 생성 (명령들)
const tvOnCmd = new TVOnCommand(livingRoomTV);
const tvOffCmd = new TVOffCommand(livingRoomTV);
const volumeUpCmd = new VolumeUpCommand(livingRoomTV);
const coolCmd = new AirConditionerCommand(bedroomAircon, 20);

// 3. Invoker 생성 (리모컨)
const remote = new RemoteControl();

// 4. 리모컨 버튼에 명령 할당
remote.setCommand('전원', tvOnCmd);
remote.setCommand('끄기', tvOffCmd);
remote.setCommand('볼륨+', volumeUpCmd);
remote.setCommand('냉방', coolCmd);

// 5. 사용!
remote.pressButton('전원');    // TV가 켜졌습니다. [전원] 버튼이 눌렸습니다.
remote.pressButton('볼륨+');   // 볼륨이 15로 설정되었습니다. [볼륨+] 버튼이 눌렸습니다.
remote.pressButton('냉방');    // 온도가 20도로 설정되었습니다. [냉방] 버튼이 눌렸습니다.
remote.pressUndo();           // 온도가 24도로 설정되었습니다. [UNDO] 버튼이 눌렸습니다.
```

**NoCommand 객체**
일종의 null object입니다. 딱히 리턴할 객체도 없고 클라이언트가 null을 처리하지 않게 하고 싶을 때 활용하면 좋습니다.
아직 명령이 할당되지 않은 부분에 NoCommand 객체를 넣어 execute()가 호출되어도 문제가 생기지 않도록 합니다.

```js
class NoCommand implements Command {
  execute() {}
}
```
